# compile this with
# $ peg bql.peg (creates bql.peg.go)
# using peg from https://github.com/pointlander/peg

package parser

type bqlPeg Peg {
    parseStack
}

# below come the rules, in curly braces the action
# that should be taken after parsing is complete,
# where `p` points to the `Bql` struct above and
# `buffer[begin:end]` holds the string part matching
# this rule.

Statement <- (SelectStmt / CreateStreamAsSelectStmt / CreateSourceStmt /
             CreateStreamFromSourceStmt / CreateStreamFromSourceExtStmt /
             CreateSinkStmt / InsertIntoSelectStmt) !.

SelectStmt <- "SELECT" sp
              Projections sp
              From sp
              Filter sp
              Grouping sp
              Having sp
              {
        p.AssembleSelect()
    }

CreateStreamAsSelectStmt <- "CREATE" sp "STREAM" sp
                    Relation sp
                    "AS" sp "SELECT" sp
                    EmitProjections sp
                    WindowedFrom sp
                    Filter sp
                    Grouping sp
                    Having sp
                    {
        p.AssembleCreateStreamAsSelect()
    }

CreateSourceStmt <- "CREATE" sp "SOURCE" sp
                    SourceSinkName sp
                    "TYPE" sp SourceSinkType sp
                    SourceSinkSpecs {
        p.AssembleCreateSource()
    }

CreateSinkStmt <- "CREATE" sp "SINK" sp
                    SourceSinkName sp
                    "TYPE" sp SourceSinkType sp
                    SourceSinkSpecs {
        p.AssembleCreateSink()
    }

CreateStreamFromSourceStmt <- "CREATE" sp "STREAM" sp
                    Relation sp
                    "FROM" sp "SOURCE" sp
                    SourceSinkName {
        p.AssembleCreateStreamFromSource()
    }

CreateStreamFromSourceExtStmt <- "CREATE" sp "STREAM" sp
                    Relation sp
                    "FROM" sp SourceSinkType sp "SOURCE" sp
                    SourceSinkSpecs {
        p.AssembleCreateStreamFromSourceExt()
    }

InsertIntoSelectStmt <- "INSERT" sp "INTO" sp
                    SourceSinkName sp
                    SelectStmt {
        p.AssembleInsertIntoSelect()
    }

# Projections/Columns (mandatory)

EmitProjections <- Emitter sp '(' Projections ')' {
        p.AssembleEmitProjections()
    }

Projections <- < Projection sp (',' sp Projection)* > {
        p.AssembleProjections(begin, end)
    }

Projection <- Expression

# FROM clause (optional)

WindowedFrom <- < ("FROM" sp Relations sp
                   '[' sp "RANGE" sp Range sp ']')? > {
        // This is *always* executed, even if there is no
        // FROM clause present in the statement.
        p.AssembleWindowedFrom(begin, end)
    }

Range <- NumericLiteral sp RangeUnit {
        p.AssembleRange()
    }

From <- < ("FROM" sp Relations)? > {
        // This is *always* executed, even if there is no
        // FROM clause present in the statement.
        p.AssembleFrom(begin, end)
    }

Relations <- Relation sp (',' sp Relation)*

Relation <- < [a-z]+ > {
        p.PushComponent(begin, end, NewRelation(buffer[begin:end]))
    }

# WHERE clause (optional)

Filter <- < ("WHERE" sp Expression)? > {
        // This is *always* executed, even if there is no
        // WHERE clause present in the statement.
        p.AssembleFilter(begin, end)
    }

# GROUP BY clause (optional)

Grouping <- < ("GROUP" sp "BY" sp GroupList)? > {
        // This is *always* executed, even if there is no
        // GROUP BY clause present in the statement.
        p.AssembleGrouping(begin, end)
    }

GroupList <- Expression sp (',' sp Expression)*

# HAVING clause

Having <- < ("HAVING" sp Expression)? > {
        // This is *always* executed, even if there is no
        // HAVING clause present in the statement.
        p.AssembleHaving(begin, end)
    }

# CREATE SOURCE parameters

SourceSinkName <- < [a-z]+ > {
        p.PushComponent(begin, end, SourceSinkName(buffer[begin:end]))
    }

SourceSinkType <- < [a-z]+ > {
        p.PushComponent(begin, end, SourceSinkType(buffer[begin:end]))
    }

SourceSinkSpecs <- < ("WITH" sp SourceSinkParam sp (',' sp SourceSinkParam)*)? > {
        p.AssembleSourceSinkSpecs(begin, end)
    }

SourceSinkParam <- SourceSinkParamKey '=' SourceSinkParamVal {
        p.AssembleSourceSinkParam()
    }

SourceSinkParamKey <- < [a-z0-9]+ > {
        p.PushComponent(begin, end, SourceSinkParamKey(buffer[begin:end]))
    }

SourceSinkParamVal <- < [a-z0-9]+ > {
        p.PushComponent(begin, end, SourceSinkParamVal(buffer[begin:end]))
    }

# The rules below are for implementing nested expressions such
# as `a + 3 = b OR a = b AND b > 0`.
# Note: If we implement this the straightforward
# `Expr <- Expr / (Expr "+" Expr) / ...` way, we will run into
# infinite recursion.
# Also note: If we use
# `plusMinusExp <- (multExp "+" multExp) / (multExp "-" multExp)`
# instead of
# `plusExp <- (minusExp "+" minusExp)
# `minusExp <- (multExp "-" multExp)
# (in spirit) then for some reason this will not catch the "-"
# operations properly.

Expression <- < andExpr sp ("OR" sp andExpr)? > {
        p.AssembleBinaryOperation(begin, end, "OR")
    }

andExpr <-    < eqExpr sp ("AND" sp eqExpr)? > {
        p.AssembleBinaryOperation(begin, end, "AND")
    }

eqExpr <-     < addExpr sp ("=" sp addExpr)? > {
        p.AssembleBinaryOperation(begin, end, "=")
    }

addExpr <-    < subExpr sp ("+" sp subExpr)? > {
        p.AssembleBinaryOperation(begin, end, "+")
    }

subExpr <-    < multExpr sp ("-" sp multExpr)? > {
        p.AssembleBinaryOperation(begin, end, "-")
    }

multExpr <-   < divExpr sp ("*" sp divExpr)? > {
        p.AssembleBinaryOperation(begin, end, "*")
    }

divExpr <-    < baseExpression sp ("/" sp baseExpression)? > {
        p.AssembleBinaryOperation(begin, end, "/")
    }

# note that the order of literals is important in baseExpression
baseExpression <- ('(' sp Expression sp ')') /
    ColumnName / FloatLiteral / NumericLiteral

ColumnName <- < [a-z]+ > {
        p.PushComponent(begin, end, NewColumnName(buffer[begin:end]))
    }

NumericLiteral <- < '-'? [0-9]+ > {
        p.PushComponent(begin, end, NewNumericLiteral(buffer[begin:end]))
    }

FloatLiteral <- < '-'? [0-9]+ '.' [0-9]+ > {
        p.PushComponent(begin, end, NewFloatLiteral(buffer[begin:end]))
    }

Emitter <- ISTREAM / DSTREAM / RSTREAM

ISTREAM <- < "ISTREAM" > {
        p.PushComponent(begin, end, Istream)
    }

DSTREAM <- < "DSTREAM" > {
        p.PushComponent(begin, end, Dstream)
    }

RSTREAM <- < "RSTREAM" > {
        p.PushComponent(begin, end, Rstream)
    }

RangeUnit <- TUPLES / SECONDS

TUPLES <- < "TUPLES" > {
        p.PushComponent(begin, end, Tuples)
    }

SECONDS <- < "SECONDS" > {
        p.PushComponent(begin, end, Seconds)
    }

sp <- ( ' ' / '\t' / '\n' )*
