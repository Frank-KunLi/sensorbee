package dummy_source

import (
	"fmt"
	"pfi/sensorbee/sensorbee/bql"
	"pfi/sensorbee/sensorbee/core"
	"pfi/sensorbee/sensorbee/tuple"
	"sync"
	"time"
)

func init() {
	// register with BQL
	bql.RegisterSourceType("dummy", CreateDummySource)
}

// MkTuples creates a slice of `num` Tuples with increasing
// timestamp and Data that holds a strictly increasing int
// value at the "int" key.
func MkTuples(num int) []*tuple.Tuple {
	tuples := make([]*tuple.Tuple, 0, num)
	for i := 0; i < num; i++ {
		tup := tuple.Tuple{
			Data: tuple.Map{
				"int": tuple.Int(i + 1),
			},
			InputName:     "input",
			Timestamp:     time.Date(2015, time.April, 10, 10, 23, i, 0, time.UTC),
			ProcTimestamp: time.Date(2015, time.April, 10, 10, 24, i, 0, time.UTC),
			BatchID:       7,
		}
		tuples = append(tuples, &tup)
	}
	return tuples
}

// CreateDummySource creates a source that emits a number
// of Tuples as generated by MkTuples. The number of Tuples
// is 4 by default, but can be changed using the "num" key of
// the params map.
func CreateDummySource(ctx *core.Context, params tuple.Map) (core.Source, error) {
	numTuples := 4
	// check the given source parameters
	for key, value := range params {
		if key == "num" {
			numTuples64, err := tuple.AsInt(value)
			if err != nil {
				msg := "num: cannot convert value %s into integer"
				return nil, fmt.Errorf(msg, value)
			}
			numTuples = int(numTuples64)
		} else {
			return nil, fmt.Errorf("unknown source parameter: %s", key)
		}
	}

	s := &tupleEmitterSource{Tuples: MkTuples(numTuples)}
	s.c = sync.NewCond(&s.m)
	return s, nil
}

// tupleEmitterSource is a source that emits all tuples in the given
// slice when GenerateStream is called.
type tupleEmitterSource struct {
	Tuples []*tuple.Tuple
	m      sync.Mutex
	c      *sync.Cond

	// 0: running, 1: stopping, 2: stopped
	state int
}

func (s *tupleEmitterSource) GenerateStream(ctx *core.Context, w core.Writer) error {
	for _, t := range s.Tuples {
		s.m.Lock()
		if s.state > 0 {
			s.state = 2
			s.c.Broadcast()
			s.m.Unlock()
			break
		}
		s.m.Unlock()

		w.Write(ctx, t)
	}

	s.m.Lock()
	defer s.m.Unlock()
	s.state = 2
	s.c.Broadcast()
	return nil
}

func (s *tupleEmitterSource) Stop(ctx *core.Context) error {
	s.m.Lock()
	defer s.m.Unlock()
	if s.state == 2 {
		return nil
	}
	s.state = 1
	s.c.Broadcast()
	for s.state < 2 {
		s.c.Wait()
	}
	return nil
}
